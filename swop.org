* Eerste sessie
- mogen we libraries gebruiken?
    Ja
    Zeker:
        - Guava: pure collections
        - Yaml:

- wat voor documentatie schrijven we nu?
    OGP, maar informeel.

- welke diagrammen moeten we maken?
    - Hoog niveau: class diagram
    - Momenteel geen domain model (gegeven)
    - Inzoomen:
        - class diagram
        - sequence diagram
        ²

    Zorg dat we ons design kunnen 'verkopen'


- Hoe zit het met de UML die we nu hebben?


- Moeten we een sequence diagram maken voor elke use-case?
    Nope, maar wel van de interne werking.
    Gewoon geen letterlijke vertaling van de opgave.
- Moeten we nog iets doen met dat domain model?
    Nee, dat is gegeven voor deze iteratie

* Tweede sessie
- Vragen
  - Recursief falen?
    Nee
  - Lazy evaluation van alles ivm tijd?
    NOPE
  - Performed-during, is dat een clock of is dat één begin en één einde?
    één begin en één einde
  - Wie beslist er over de status verandering? Task, status, of nog iets anders?

- Beslissingen
  - Depends on is NIET bidirectioneel
  - Ultimate time travel: events en time traveling object - nope!

- Bij assistent geleerd:
  - facade controller
  - session controller
  - UI interface

* Vragen via mail sinds dat we fatsoenlijk zijn beginnen programmeren

- Wanneer moeten lijsten 'immutable' worden? Gebeurt dit als we Project.getTasks() doen vanuit het domain zelf? Doet de facade controller dat als hij de lijst door geeft aan de sessioncontroller? Of wordt de bescherming pas gedaan als de sessionController de lijst door geeft aan de userInterface?
  - Interne collecties worden best steeds afgeschermd (dus de interne collectie van taken in een object van de klasse Project mag buiten dat object nergens aangepast kunnen worden, ook niet binnen jullie domein). Je kan dat doen door immutable lists te gebruiken of door steeds te kopieren bij setten en getten.

- Verder, als we een lijst van Tasks willen van een Project in de sessionController. Vraagt de sessionController dan rechtstreeks aan het Project voor deze lijst? Of is het beter dat de FacadeController een functie 'getTasksForProject(Project)' heeft die dan op zijn beurt vraagt aan het meegegeven project voor de lijst van tasks?
- Er is hier geen beste oplossing. Je zal hier een evenwicht moeten zoeken. Let wel op dat jullie klasse FacadeController niet gigantisch wordt. Wees per klasse echter wel consistent in je keuze.

- Als laatste was er een zeker discutie over hoe de sessionController te structureren. Momenteel hebben we één functie per use-case in een classe 'SessionController'. Alternatief kunnen we verschillende klassen laten overerven van SessionController, één sub-classe per use-case. De meningen zijn een beetje verdeeld over wat het gemakkelijkste in gebruik is, en wat het beste design is. Wat is u mening hierover?
- Beide zijn waardige alternativen, ze kunnen beide goed zijn. Belangrijk is wel dat als er in alle use cases gemeenschappelijk gedrag is, dit best toch maar op 1 plaats geimplementeerd wordt. Ik zou zeggen kies en zie later waar de beperkingen van die keuze naar boven komen (beide hebben andere beperkingen).

- Bij maken van TaskProxy, krijgt die een realTask of Task(interface) mee?
  - Meerdere lagen proxy's?
  - Vraag aan proxy: 'getDependency()', geeft een Task(interface) terug.

- UUID?
  - UI selecteerd een project uit set<Project> en geeft deze terug. Hoe hier mee verder werken?
